<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>
    嵌入式操作系统 | NIUHE | Be Myself Enjoy My Life
  </title>

  
  <meta name="author" content="NIUHE">
  

  
  <meta name="description" content="NIUHE&#39;s Blog">
  

  
  <meta name="keywords" content="编程,读书,学习笔记">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  
  <meta property="og:title" content="嵌入式操作系统">
  

  <meta property="og:site_name" content="NIUHE">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/icon.png" type="image/png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="NIUHE" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <script type="text/javascript" src="/js/social-share.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-71540601-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }
    gtag('js', new Date());

    gtag('config', 'UA-71540601-1');
</script>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="blog">
    <div class="content">

      <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">NIUHE</a>
    </h1>
    <p class="site-description">Be Myself Enjoy My Life</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">目录</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
    </ul>
  </nav>
</header>

      <main class="site-main posts-loop">
        <article>

  
  
  <h3 class="article-title"><span>
      嵌入式操作系统</span></h3>
  
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/01/06/操作系统/" rel="bookmark">
        <time class="entry-date published" datetime="2017-01-06T04:08:47.000Z">
          2017-01-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
      <p><strong>目录</strong></p>
<!-- toc -->
<ul>
<li><a href="#第一章">第一章</a></li>
<li><a href="#第二章">第二章</a></li>
<li><a href="#第三章">第三章</a></li>
<li><a href="#第四章">第四章</a></li>
<li><a href="#第五章">第五章</a></li>
<li><a href="#第六章">第六章</a></li>
<li><a href="#第七章">第七章</a></li>
<li><a href="#第八章">第八章</a></li>
<li><a href="#tinyos">TinyOS</a></li>
</ul>
<!-- tocstop -->
<a id="more"></a>
<h2><span id="第一章">第一章</span></h2>
<ul>
<li>多道
<ul>
<li>多道程序设计技术是在计算机主存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插地运行。<strong>当一个程序无法使用处理器资源的时候（做I/O的时候），系统可以调用另一个程序在处理器上运行。</strong></li>
<li>特征：多道、宏观上并行、微观上串行</li>
</ul></li>
<li>分时
<ul>
<li>分时技术是将处理器的时间<strong>分成很短的时间片</strong>，将这些时间片<strong>轮流分配给在内存中的用户程序使用</strong>。</li>
<li>分时系统具有的特点
<ol type="1">
<li>独立性（各用户感觉独占资源）</li>
<li>及时性</li>
<li>交互性</li>
</ol></li>
</ul></li>
<li>并发
<ul>
<li>在系统里有多个同时进行的活动</li>
</ul></li>
<li>共享
<ul>
<li>进程之间共享系统资源</li>
</ul></li>
<li>不确定性
<ul>
<li>系统中含有大量不确定的事件</li>
</ul></li>
</ul>
<h2><span id="第二章">第二章</span></h2>
<ul>
<li>硬件支持：
<ol type="1">
<li>处理机的状态：目态、管态
<ol type="1">
<li>管态指CPU上运行管理程序所处的状态，目态是指CPU上运行用户程序所处的态；</li>
<li>二者的区别：特权级不同，CPU在管态下可以使用全部机器指令，包括一组特权指令，可以使用所有的资源，访问整个存储区。CPU在用户态下只能使用用户态非特权指令，访问规定的存储区，使用一部分资源。</li>
<li>从用户态到管态切换的唯一途径是中断</li>
</ol></li>
<li>特权指令
<ol type="1">
<li>改变机器状态的指令</li>
<li>修改特殊寄存器的指令</li>
<li>涉及外部设备的输入/输出指令</li>
</ol></li>
</ol></li>
<li>中断
<ul>
<li>中断实质是一个受保护的控制转移(protected control transfer)</li>
<li>中断分类：I/O、外中断、机器故障中断、程序性中断、访管中断</li>
<li>操作系统具备处理同时性活动的能力，重要的硬件支持是：中断系统</li>
</ul></li>
</ul>
<h2><span id="第三章">第三章</span></h2>
<ul>
<li>系统功能调用
<ul>
<li>命令行</li>
<li>图形用户界面</li>
</ul></li>
<li>程序接口</li>
</ul>
<h2><span id="第四章">第四章</span></h2>
<ul>
<li><p>并发：若干个程序段同时在系统中运行，若这些程序的执行在时间上存在重叠，则称为程序并发执行。</p>
<ul>
<li>特点：失去了封闭性；程序与计算不再一一对应</li>
</ul></li>
<li><p>进程</p>
<ul>
<li>进程是一个程序在给定的初始环境和活动空间下，在处理机上的一次执行过程</li>
<li>组成
<ul>
<li>进程控制块</li>
<li>进程的执行程序</li>
<li>进程总是处于某个队列</li>
<li>处于某种状态</li>
<li>占用系统某些资源</li>
</ul></li>
</ul></li>
<li><p>线程</p>
<ul>
<li>轻量级进程</li>
</ul></li>
<li>状态变迁
<ul>
<li>无 等待-》运行 ❌</li>
<li>无 就绪-》等待 ❌</li>
<li><img src="/images/OS/process_state_trans.png"></li>
<li>如果系统中有N个进程，运行的进程最多几个，最少几个；就绪、等待呢？
<ul>
<li>运行的进程最多一个，最少0个</li>
<li>就绪最多N - 1个，最少0个</li>
<li>等待最多N个，最少0个</li>
</ul></li>
<li>一个状态的发生，是否一定导致另一个状态的发生？列出所有可能
<ul>
<li>运行 -&gt; 就绪 一定有 就绪 -&gt; 运行</li>
<li>就绪 -&gt; 运行 不一定有 运行 -&gt; 就绪</li>
</ul></li>
</ul></li>
<li><p>合作关系</p>
<ul>
<li><p>进程的相互制约关系产生原因：资源共享、进程合作</p></li>
<li><p>互斥</p>
<ul>
<li>当某一进程正在访问某临界资源时，就不允许其他进程进入，否则就会产生无法估计的错误。</li>
<li>源于对独占设备的竞争</li>
</ul></li>
<li><p>同步</p>
<ul>
<li><p>源于进程的合作</p></li>
<li><p>共享缓冲区的合作进程同步</p>
<ul>
<li><p>生产者-消费者问题</p>
<ul>
<li><p>Full：缓冲区产品数目，初值为0</p></li>
<li><p>Empty：缓冲区可存放产品的空位，初值为n</p></li>
<li><p>Mutex:缓冲区互斥信号灯，初值为1</p></li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(生产未完成) &#123;</span><br><span class="line">    生产一个产品;</span><br><span class="line">    p(empty);</span><br><span class="line">    p(mutex);</span><br><span class="line">    将产品放入缓冲区;</span><br><span class="line">    v(mutex);</span><br><span class="line">    v(full);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (还要继续消费) &#123;</span><br><span class="line">    p(full);</span><br><span class="line">    p(mutex);</span><br><span class="line">    从缓冲区取出一个产品;</span><br><span class="line">    v(mutex);</span><br><span class="line">    v(empty);</span><br><span class="line">    消费产品;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>读者写者问题？</p></li>
<li><p>誊抄问题</p></li>
</ul></li>
</ul></li>
<li><p>在地球上，竞争和合作是永恒的！</p></li>
<li><p>临界资源</p>
<ul>
<li>一次仅允许一个进程访问的资源</li>
</ul></li>
<li><p>临界区</p>
<ul>
<li>每个进程中访问临界资源的<strong>程序段</strong>称为临界区</li>
</ul></li>
<li><p>原子、原语：不可分割、不可中断的程序</p></li>
<li><p>信号灯P、V操作</p>
<ul>
<li><p>P</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  s--;</span><br><span class="line">  <span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    挂起该进程;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>V</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  s++;</span><br><span class="line">  <span class="keyword">if</span> (s &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    唤醒等待S的进程;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>信号灯（s, q）</p>
<ul>
<li>s代表可用资源的数目，初值应该大于等于0</li>
</ul></li>
<li><p><img src="/images/OS/process_corporate.png"></p></li>
<li><p>s13 = 0 表示进程P1尚未执行完成</p></li>
<li><p>s23 = 0 表示进程P2尚未执行完成</p></li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	....;</span><br><span class="line">  	v(s13);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	....;</span><br><span class="line">  	v(s23);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	p(s13);</span><br><span class="line">  	p(s23);</span><br><span class="line">  	.....;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>思路：为每个只能在进程i结束后才能执行的进程j设置是否可开始的信号灯<span class="math inline">\(S_{ij}\)</span>，其初值为0，这些进程执行前先对<span class="math inline">\(S_{ij}\)</span>进行p操作。</p></li>
</ul></li>
</ul></li>
<li>IPC
<ul>
<li><p>fork</p>
<ul>
<li><p>子进程值为0，父进程中为一大于0整数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> p1, p2, p3;</span><br><span class="line"><span class="keyword">if</span> ((p1 = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    execv(<span class="string">"./get"</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((p2 = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    execv(<span class="string">"./copy"</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((p3 = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    execv(<span class="string">"./put"</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>并发实践，P80左右，注意有无else</p></li>
</ul></li>
<li><p>线程</p>
<ul>
<li>线程(Thread)是一个动态的对象，是处理机调度的基本单位，表示一个进程中的一个控制点，执行一系列的指令。</li>
<li>进程是系统资源的分配单位；线程是处理机调度的对象</li>
<li>与进程相同的地方
<ul>
<li>线程共享父进程的代码段和数据段，拥有相同的优先级</li>
</ul></li>
<li>不同的地方
<ul>
<li>每个线程拥有自己的PC，寄存器和栈指针</li>
</ul></li>
<li>上下文切换
<ul>
<li>同一个进程中线程切换简单，因为进程中所有线程是共享一个上下文的</li>
</ul></li>
<li>实验
<ul>
<li>飞机售票</li>
</ul></li>
</ul></li>
<li>调度
<ul>
<li><p>循环轮转</p>
<p><img src="/images/OS/rotate.png"></p>
<ul>
<li>固定时间片
<ul>
<li>优点：实现简单、系统开销小</li>
<li>缺点：不灵活，当系统中进程较少时，系统开销大</li>
</ul></li>
</ul></li>
<li><p>优先级</p>
<ul>
<li>多级反馈队列调度算法</li>
</ul>
<p><img src="/images/OS/priority&amp;timeslice.png"></p>
<p><img src="/images/OS/优先级.png"></p>
<ul>
<li>I/O量大-&gt;高优先就绪队列，<strong>优先照顾</strong></li>
<li>计算量大-&gt;低优先就绪队列，但一次可执行500ms，<strong>适当照顾</strong></li>
<li>I/O多-&gt;优先执行，系统的外部设备经常忙</li>
<li>I/O少-&gt;时间片长，上下文切换少系统开销小</li>
</ul></li>
</ul></li>
</ul>
<h2><span id="第五章">第五章</span></h2>
<ul>
<li>死锁
<ul>
<li>死锁就是两个或两个以上的进程等候着一个永远不会发生的事件时所处的一种系统状态。</li>
<li>四个必要条件
<ul>
<li>互斥-Mutual Exclusion</li>
<li>不可剥夺-No preemption</li>
<li>部分分配-Hold and wait</li>
<li>循环等待-Circular wait</li>
</ul></li>
</ul></li>
<li>预防
<ul>
<li>预先分配一个进程要用的所有资源（静态分配）是防止死锁的一种安全而简单的方法
<ul>
<li>破坏部分分配条件</li>
<li>缺点：设备（资源）的浪费太大</li>
</ul></li>
</ul></li>
<li>避免
<ul>
<li>有序资源分配
<ul>
<li>系统中的所有资源统一编号（如打印机为1，磁带机为2...）</li>
<li>申请时必须以上升的次序</li>
<li>系统要求
<ul>
<li>对必须使用的而且属于同一类的资源，必须一次申请完</li>
<li>在申请不同类资源时，必须按设备编号依次申请</li>
</ul></li>
</ul></li>
<li>最简单的银行家算法（书上的例子）
<ul>
<li>银行家算法要求进入系统的进程必须说明它对各类资源类型的实例的最大需求量。这一数量不能超过系统各类资源的总数。当进程申请一组资源时，该算法需要检查申请者对各类资源的最大需求量，<strong>如果系统现存的各类资源的数量可以满足当前它对各类资源的最大需求量，就满足当前的申请</strong>；否则进程必须等待，直到其他进程释放足够的资源为止。</li>
<li>问题
<ul>
<li>考察每个进程对各个资源的申请需花费较多的时间</li>
<li>过于谨慎</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2><span id="第六章">第六章</span></h2>
<ul>
<li>映射
<ul>
<li>逻辑、物理转换</li>
<li>静态地址映射
<ul>
<li>在作业装入过程中进行地址映射</li>
<li>需软件重定位装入程序</li>
<li>需要花费较多CPU时间</li>
<li>不灵活</li>
</ul></li>
<li>动态地址映射
<ul>
<li>在程序执行期间进行地址映射</li>
<li>需要硬件地址变换机构-重定位寄存器</li>
<li>地址变换快</li>
<li>灵活</li>
</ul></li>
</ul></li>
<li><p>分配</p>
<ul>
<li>放置策略</li>
<li>调入策略
<ul>
<li>请调</li>
<li>预调</li>
</ul></li>
<li>淘汰策略</li>
</ul></li>
<li>扩充
<ul>
<li>虚拟存储-为用户提供一种不受物理存储器结构和容量限制的存储器</li>
<li>核心
<ul>
<li>程序执行的局部性原理</li>
<li>逻辑地址和物理地址的分离</li>
</ul></li>
</ul></li>
<li>保护
<ul>
<li>上下界 -&gt; 物理
<ul>
<li>下界寄存器：存放程序装入内存后的开始地址</li>
<li>上界寄存器：存放程序装入内存后的末地址</li>
<li>（下界寄存器）<span class="math inline">\(\le\)</span> 物理地址 &lt; （上界寄存器）</li>
</ul></li>
<li>基址限长 -&gt; 逻辑
<ul>
<li>0 <span class="math inline">\(\le\)</span> 逻辑地址 &lt; 限长</li>
</ul></li>
<li>仅适用于连续分配</li>
</ul></li>
<li>动态分区
<ul>
<li><p>自由主存队列</p>
<p><img src="/images/OS/M_RIB.png"><img src="/images/OS/PD.png"></p>
<p><img src="/images/OS/free.png"></p></li>
<li><p>首次适应算法</p>
<ul>
<li><p>按空闲区首址升序的方法组织</p></li>
<li><p>尽可能地利用低地址的空闲区，而尽量地保证高地址的大空闲区</p>
<p><img src="/images/OS/first.png"></p></li>
</ul></li>
<li><p>最佳适应算法</p>
<ul>
<li><p>按空闲区大小升序方法组织</p></li>
<li><p>将申请者放入与其大小最接近的空闲区中</p></li>
<li><p>若系统中存在与申请区大小相等的空闲区，这种算法肯定能将这种空闲区分配给申请者（首次适应则不一定）</p>
<p><img src="/images/OS/best.png"></p></li>
</ul></li>
<li><p>最坏适应算法</p>
<ul>
<li><p>按空闲区大小降序的方法组织</p></li>
<li><p>将最大的空闲区切去一部分给请求者</p></li>
<li><p>克服最佳适应算法把空闲区分割得太小的缺点</p>
<p><img src="/images/OS/worst.png"></p></li>
</ul></li>
<li><p>高、低地址优先</p></li>
</ul></li>
<li>页式系统
<ul>
<li><p>页表</p>
<table>
<thead>
<tr class="header">
<th>页号</th>
<th>块号</th>
</tr>
</thead>
<tbody>
</tbody>
</table></li>
<li><p>快表</p>
<ul>
<li>Translation Look-aside Buffers, TLB</li>
</ul></li>
<li><p>地址变换过程</p>
<p><img src="/images/OS/trans.png"></p>
<p>内存地址 = 块号 * 页大小 + 位移量</p>
<ul>
<li>按字节编址</li>
<li>1KB = 10位</li>
<li>2KB = 11位</li>
<li>1MB = 20位</li>
<li>1GB = 30位</li>
</ul>
<p>程序地址以十进制给出</p>
<ul>
<li>页号 = 虚地址 % 页大小</li>
<li>位移量 = 虚地址 mod 页大小</li>
</ul></li>
<li><p>TLB</p>
<p><img src="/images/OS/TLB.png"></p>
<ul>
<li>查TLB = <span class="math inline">\(\epsilon\)</span> 时间</li>
<li>查内存 = 1 毫秒</li>
<li>命中率 = <span class="math inline">\(\alpha\)</span></li>
<li>Effective Access Time(EAT) = <span class="math inline">\((1+\epsilon)\alpha+(2+\epsilon)(1-\alpha)\)</span></li>
</ul></li>
<li><p>请求分页，扩充页表位</p>
<ul>
<li><p>扩展页表</p>
<table>
<thead>
<tr class="header">
<th>页号</th>
<th>块号</th>
<th>中断</th>
<th>辅存地址</th>
<th>引用</th>
<th>修改</th>
<th>访问方法</th>
</tr>
</thead>
<tbody>
</tbody>
</table></li>
<li><p>中断位：0 -&gt; 在内存，1 -&gt; 不在内存</p></li>
<li><p>引用位：0 -&gt; 没有进程访问，1 -&gt; 有进程访问</p></li>
<li><p>修改位：0 -&gt; 调入后没修改，2 -&gt; 调入后修改过</p></li>
</ul></li>
<li><p>页面置换算法</p>
<ul>
<li><p>先进先出</p>
<ul>
<li>建立一个页面进入主存的先后次序表</li>
<li>建立一个替换指针，指向最早进入主存的页面</li>
<li>当需要置换一页时，选择替换指向的一页，然后调整替换指针的内容</li>
<li>每次有新页面进入内存更新次序表</li>
</ul></li>
<li><p>LRU-Least Recently Used</p>
<ul>
<li><p>需要淘汰页时，选择最长时间未使用的页</p>
<p><img src="/images/OS/LRU.png"></p></li>
</ul></li>
<li><p>近似LRU（实现）</p>
<p><img src="/images/OS/LRU流程.png"></p>
<p><img src="/images/OS/LRUeg.png"></p></li>
</ul></li>
</ul></li>
<li><p>页式系统最终面貌</p>
<p><img src="/images/OS/page.png"></p>
<p>优点：</p>
<ul>
<li>不要求作业的程序和数据段在内存中连续存放，解决了碎片问题</li>
<li>可以利用的存贮空间大大增加，提高了主存利用率</li>
<li>请求式系统提供了统一管理的虚拟存储实现方案</li>
</ul>
<p>缺点：</p>
<ul>
<li>硬件支持，成本</li>
<li>系统开销大，页表维护与管理，缺页中断</li>
<li>抖动</li>
</ul></li>
<li><p>段页式系统</p>
<ul>
<li>区别、变换
<ul>
<li>页是物理单位，段是逻辑单位</li>
<li>页大小是固定的，段大小不固定</li>
</ul></li>
<li>段页式系统：段内分页</li>
<li>难度小于课件上例子</li>
</ul></li>
</ul>
<h2><span id="第七章">第七章</span></h2>
<ul>
<li>独立性：用户在编程式所使用的设备与实际设备无关
<ul>
<li>逻辑设备名：用户指定的设备名（可更改的）</li>
<li>物理名：系统提供的设备的标准名称（不可更改）</li>
<li>优点
<ul>
<li>方便用户</li>
<li>改善设备利用率</li>
<li>提高系统的可扩展性和可适应性</li>
</ul></li>
</ul></li>
<li><p>独占设备：采用动态分配有可能造成死锁</p>
<ul>
<li>让一个设备在整个运行区间独占使用</li>
</ul></li>
<li><p>共享设备：不会死锁</p>
<ul>
<li>由多个作业、进程共同使用的设备</li>
</ul></li>
<li><p>设备分配</p>
<ul>
<li>先来先服务</li>
<li>优先级高者优先</li>
<li>独占分配：在一作业执行前，将它所要使用的设备分配给它；当它结束撤离时，将分配给它的这类设备收回</li>
<li>共享分配：动态分配，进程提出资源申请，由设备管理模块进行分配，进程使用完毕后立即归还</li>
<li>虚拟分配
<ul>
<li>将独占设备转换为共享设备的一种技术</li>
<li>通常把用来代替独占类型设备的那部分外存空间称为<strong>虚拟设备</strong></li>
<li>当进程需要与独占设备交换信息时，系统将分配磁盘空间，并建立相应的数据结构，这种分配方法称为虚拟分配</li>
</ul></li>
</ul>
<p>​</p></li>
<li>缓冲管理
<ul>
<li><p>预存缓写</p></li>
<li><p>不让进程长时间等待外设完成操作</p></li>
<li><p>缓写</p>
<p><img src="/images/OS/缓冲.png"></p></li>
</ul></li>
</ul>
<h2><span id="第八章">第八章</span></h2>
<ul>
<li>文件
<ul>
<li>逻辑结构
<ul>
<li>流式 Byte Sequence
<ul>
<li>无结构，流式文件是相关的字符的集合，文件的长度为所含字符数</li>
</ul></li>
<li>记录式 Record Structure
<ul>
<li>记录式文件是记录的集合，每个记录由相关的域构成</li>
</ul></li>
</ul></li>
<li>物理结构
<ul>
<li><p>连续文件</p>
<ul>
<li>文件内容存放在连续编号的磁盘块中</li>
<li>优点
<ul>
<li>结构简单，容易实现</li>
<li>不需要额外开销</li>
</ul></li>
<li>缺点
<ul>
<li>空间利用率低</li>
<li>不利于文件的动态增加和修改</li>
</ul></li>
</ul></li>
<li><p>串联文件</p>
<ul>
<li>文件的内容放在若干不要求连续编号的磁盘块中</li>
<li>一个文件占用的磁盘块链接成一个磁盘块链，链接指针存放在每磁盘块的最末一个字（或第一个字）</li>
<li>优点
<ul>
<li>存储空间利用率高</li>
<li>文件动态扩充和修改容易</li>
</ul></li>
<li>缺点
<ul>
<li>随机存取效率太低</li>
</ul></li>
</ul></li>
<li><p>FAT</p>
<ul>
<li>文件映照</li>
<li>把串联文件中的链接集中在一个结构中，这样既保持了串联文件的优点，也克服了其缺点</li>
</ul>
<p><img src="/images/OS/FAT.png"></p></li>
<li><p>索引文件</p>
<ul>
<li>每个文件有一个索引表，登记文件的逻辑块与物理块间的对应关系</li>
</ul>
<p><img src="/images/OS/index.png"></p>
<ul>
<li>i_addr[0]~i_addr[9] 为直接索引</li>
<li>i_addr[10]为一级间接索引块</li>
<li>i_addr[11]为二级间接索引块</li>
<li>i_addr[12]为三级间接索引块</li>
</ul></li>
</ul></li>
</ul></li>
<li>空闲空间
<ul>
<li><p>位示图</p>
<ul>
<li><p>用一个位向量表示哪一块空闲</p>
<p><img src="/images/OS/bitmap.png"></p></li>
</ul></li>
<li><p>成组连接-Grouping</p>
<p><img src="/images/OS/group.png"></p>
<ul>
<li><p>空闲inode</p>
<ul>
<li>s_nfree 空闲块数，初值为1</li>
<li>s_free[100] 空闲块块号，s_free[0]初值为0</li>
</ul></li>
<li><p>第一组是99块，中间都是100块，最后一组&lt;=100块</p></li>
<li><p>回收算法free</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s_nfree &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    s_free[s_nfree++] = 释放磁盘块号;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    将s_free[]写到释放磁盘块中;</span><br><span class="line">    s_nfree = <span class="number">1</span>;</span><br><span class="line">    s_free[<span class="number">0</span>] = 释放磁盘号;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分配算法alloc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">磁盘块 alloc()</span><br><span class="line">&#123;</span><br><span class="line">  s_nfree--;</span><br><span class="line">  <span class="keyword">if</span> (s_nfree == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s_free[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">      sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    a = s_free[<span class="number">0</span>];</span><br><span class="line">    将s_free[<span class="number">0</span>]块读到filsys;</span><br><span class="line">    s_nfree = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s_free[s_nfree];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>文件图示
<ul>
<li><p>树形</p>
<p><img src="/images/OS/filetree.png"></p>
<ul>
<li><p>目录文件是有文件目录项组成的文件</p></li>
<li><p>文件目录项由文件名和inode组成</p>
<table>
<thead>
<tr class="header">
<th>文件名</th>
<th>inode</th>
</tr>
</thead>
<tbody>
</tbody>
</table></li>
</ul>
<p><strong>inode</strong></p>
<p><img src="/images/OS/inode.png"></p></li>
<li><p>绝对／相对路径</p></li>
<li><p>链接</p>
<ul>
<li>硬链接：目录项中指向同一个inode</li>
<li>软链接：目录项中指向不同的inode，链接文件的磁盘块里存储链接对象的inode</li>
</ul></li>
<li><p>文件共享</p>
<ul>
<li>被多个用户使用，由存取权限控制</li>
<li>被多个进程使用，但各用自己的读写指针</li>
<li>被多个进程使用，但共享读写指针</li>
</ul></li>
<li><p>文件操作（FCB）</p>
<p><img src="/images/OS/FCB.png"></p>
<ul>
<li>打开</li>
<li>重命名</li>
<li>移动</li>
</ul></li>
</ul></li>
</ul>
<h2><span id="tinyos">TinyOS</span></h2>
<ul>
<li>组件化编程，连接配置文件
<ul>
<li>Application = Graph of Components</li>
</ul></li>
<li>执行机制
<ul>
<li>分阶段作业，无阻塞</li>
<li>主动消息通信</li>
</ul></li>
<li>中断</li>
<li>事件
<ul>
<li>事件驱动</li>
<li>优先级高于任务</li>
</ul></li>
<li>任务
<ul>
<li>轻量级线程。任务之间平等，不能相互抢占，先入先出进行调度</li>
<li>任务一般用于对时间要求不是很高的应用中，要求每个任务都很短小，能够使系统的负担较轻</li>
<li>不能有返回值和参数</li>
</ul></li>
</ul>
<p><strong>习题</strong></p>
<ol type="1">
<li>输入输出控制的主要功能是什么？
<ul>
<li>解释用户的I/O系统调用命令</li>
<li>设备驱动</li>
<li>中断处理</li>
</ul></li>
<li>实时系统的基本特征：
<ul>
<li>安全性</li>
<li>实时性</li>
<li>高可靠</li>
<li><strong>没有</strong>公平响应！</li>
</ul></li>
<li>文件的物理结构：
<ul>
<li>连续</li>
<li>串联</li>
<li>索引</li>
</ul></li>
<li>设备独立性是指<strong>用户程序中使用的设备独立于具体的物理设备</strong></li>
<li>所谓操作系统虚拟机的概念，是指<strong>在裸机上配置操作系统</strong></li>
<li>常用的资源分配策略有优先调度和<strong>先来先服务</strong>两种</li>
<li>文件目录采用树型结构而不采用简单表结构的最主要原因是<strong>解决重名问题</strong></li>
<li>在请求分页系统中，为实现淘汰页面的功能，在页表中增加<strong>引用位</strong>和<strong>改变位</strong>两个数据项</li>
<li>常用的设备分配技术有独占分配、共享分配和<strong>虚拟分配</strong>3种</li>
<li>文件系统中的链接技术，指的是在<strong>目录表目</strong>之间进行链接</li>
<li>操作系统是由一组资源管理程序组成的，其中<strong>文件系统</strong>是对软件资源的管理。</li>
<li>UNIX缓冲管理中，使用的队列结构有<strong>空闲缓冲区队列</strong>和<strong>设备缓冲区队列</strong>两种</li>
<li>在整个中断向量处理过程中，硬件负责<strong>中断响应</strong>过程</li>
<li>进程从结构上讲，包括<strong>程序、数据和PCB</strong>几个部分</li>
<li><strong>一组进程间发生了死锁</strong>，这时这些进程都占有资源</li>
<li><strong>用户存取信息</strong>是用来进行I/O操作的基本单位</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

      
      

      <span class="post-categories">
        <i class="icon-categories"></i>
        <a href="/categories/学习笔记/">学习笔记</a>
      </span>
      

      
      

      <span class="post-tags">
        <i class="icon-tags"></i>
        <a href="/tags/本科课程/">本科课程</a><a href="/tags/操作系统/">操作系统</a><a href="/tags/OS/">OS</a><a href="/tags/TinyOS/">TinyOS</a>
      </span>
      

    </div>

    
  </div>
</article>

<div class="social-share"></div>


	<section id="comment" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'Niuhe';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>



      </main>

      <footer class="site-footer">
  <p class="site-info">
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy;
    2018
    NIUHE <a href="https://github.com/NeymarL" target="_blank"><i class="fab fa-github"></i></a>
    
  </p>
</footer>
      
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
        tex2jax: {
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
  </script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });
  </script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

      <script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
    </div>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>

</html>